//******************************************************************************
//
// This file is used to generate the various "step" files, which in turn are
// used to create the various step executables.
//
// For the most part, this file is the final step file, with each line annotated
// with information that says in which step the line is introduced into the
// project. A simple filter program scans this template file, pulling out the
// lines required for a specified step.
//
// Ideally, after each line is included in a project, it stays in the project.
// This would make each step file a proper superset of the previous steps files.
// However, such idealism cannot be realized. There are cases where lines
// introduced in early step files need to be removed or replaced with new
// version.
//
// When this happens, multiple versions of a particular line can appear in the
// file. For example, consider the READ function. Early in the project, it is
// introduced as:
//
//		func READ(str: String) -> String {
//		    return str
//		}
//
// However, it is replaced in a subsequent step with:
//
//		func READ(str: String) -> MalVal {
//		    return read_str(str)
//		}
//
// To support both forms, both are included in this template file. The first is
// annotated to say that it appears in step 0 and *only* in step 0. The second
// is annotated to say that it appears in step 1 and in all subsequent versions.
//
// Where possible, in the interests for clarity, where lines are introduced and
// replaced, the entire function that is affected is introduced and replaced.
// This is as opposed to trying to surgically identify the line-by-line changes
// within a function that need to be replaced.
//
// However, in other cases, the surgical line-by-line replacement of text is
// employed. This is done in cases where the number of lines to change is small
// compared to the overall size of the function.
//
// Places where previously-introduced lines are changed or removed are marked
// with a ">>> NOTE:" comment.
//
// Lines with no annotations (like those comprising this comment block) are
// never included in any output.
//
//******************************************************************************

//******************************************************************************                                                // malstep(0,1,2,3,4,5,6,7,8,9,A)
// MAL - step 0 - repl                                                                                                          // malstep(0)
// MAL - step 1 - read/print                                                                                                    // malstep(1)
// MAL - step 2 - eval                                                                                                          // malstep(2)
// MAL - step 3 - env                                                                                                           // malstep(3)
// MAL - step 4 - if/fn/do                                                                                                      // malstep(4)
// MAL - step 5 - tco                                                                                                           // malstep(5)
// MAL - step 6 - file                                                                                                          // malstep(6)
// MAL - step 7 - quote                                                                                                         // malstep(7)
// MAL - step 8 - macros                                                                                                        // malstep(8)
// MAL - step 9 - try                                                                                                           // malstep(9)
// MAL - step A - mal                                                                                                           // malstep(A)
//******************************************************************************                                                // malstep(0,1,2,3,4,5,6,7,8,9,A)
// This file is automatically generated from templates/step.swift. Rather than                                                  // malstep(0,1,2,3,4,5,6,7,8,9,A)
// editing it directly, it's probably better to edit templates/step.swift and                                                   // malstep(0,1,2,3,4,5,6,7,8,9,A)
// regenerate this file. Otherwise, your change might be lost if/when someone                                                   // malstep(0,1,2,3,4,5,6,7,8,9,A)
// else performs that process.                                                                                                  // malstep(0,1,2,3,4,5,6,7,8,9,A)
//******************************************************************************                                                // malstep(0,1,2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(0,1,2,3,4,5,6,7,8,9,A)
import Foundation                                                                                                               // malstep(0,1,2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(0,1,2,3,4,5,6,7,8,9,A)
// The number of times EVAL has been entered recursively. We keep track of this                                                 // malstep(5,6,7,8,9,A)
// so that we can protect against overrunning the stack.                                                                        // malstep(5,6,7,8,9,A)
//                                                                                                                              // malstep(5,6,7,8,9,A)
var EVAL_level = 0                                                                                                              // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
// The maximum number of times we let EVAL recurse before throwing an exception.                                                // malstep(5,6,7,8,9,A)
// Testing puts this at some place between 1800 and 1900. Let's keep it at 500                                                  // malstep(5,6,7,8,9,A)
// for safety's sake.                                                                                                           // malstep(5,6,7,8,9,A)
//                                                                                                                              // malstep(5,6,7,8,9,A)
let EVAL_leval_max = 500                                                                                                        // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
// Control whether or not tail-call optimization (TCO) is enabled. We want it                                                   // malstep(5,6,7,8,9,A)
// `true` most of the time, but may disable it for debugging purposes (it's                                                     // malstep(5,6,7,8,9,A)
// easier to get a meaningful backtrace that way).                                                                              // malstep(5,6,7,8,9,A)
//                                                                                                                              // malstep(5,6,7,8,9,A)
let TCO = true                                                                                                                  // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
// Control whether or not we emit debugging statements in EVAL.                                                                 // malstep(5,6,7,8,9,A)
//                                                                                                                              // malstep(5,6,7,8,9,A)
let DEBUG_EVAL = false                                                                                                          // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
// String used to prefix information logged in EVAL. Increasing lengths of the                                                  // malstep(5,6,7,8,9,A)
// string are used the more EVAL is recursed.                                                                                   // malstep(5,6,7,8,9,A)
//                                                                                                                              // malstep(5,6,7,8,9,A)
let INDENT_TEMPLATE = "|----|----|----|----|----|----|----|----|" +                                                             // malstep(5,6,7,8,9,A)
    "----|----|----|----|----|----|----|----|----|----|----|" +                                                                 // malstep(5,6,7,8,9,A)
    "----|----|----|----|----|----|----|----|----|----|----|" +                                                                 // malstep(5,6,7,8,9,A)
    "----|----|----|----|----|----|----|----|----|----|----|" +                                                                 // malstep(5,6,7,8,9,A)
    "----|----|----|----|----|----|----|----|----|----|----|" +                                                                 // malstep(5,6,7,8,9,A)
    "----|----|----|----|----|----|----|----|----|----|----|" +                                                                 // malstep(5,6,7,8,9,A)
    "----|----|----|----|----|----|----|----|----|----|----|" +                                                                 // malstep(5,6,7,8,9,A)
    "----|----|----|----|----|----|----|----|----|----|----|" +                                                                 // malstep(5,6,7,8,9,A)
    "----|----|----|----|----|----|----|----|----|----|----|" +                                                                 // malstep(5,6,7,8,9,A)
    "----|----|----|----|----|----|----|----|----|----|----|" +                                                                 // malstep(5,6,7,8,9,A)
    "----|----|----|----|----|----|----|----|----|----|----|"                                                                   // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
// Holds the prefix of INDENT_TEMPLATE used for actual logging.                                                                 // malstep(5,6,7,8,9,A)
//                                                                                                                              // malstep(5,6,7,8,9,A)
var indent = String()                                                                                                           // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
// Symbols used in this module.                                                                                                 // malstep(3,4,5,6,7,8,9,A)
//                                                                                                                              // malstep(3,4,5,6,7,8,9,A)
let kSymbolArgv             = MalSymbol(symbol: "*ARGV*")                                                                       // malstep(6,7,8,9,A)
let kSymbolCatch            = MalSymbol(symbol: "catch*")                                                                       // malstep(9,A)
let kSymbolConcat           = MalSymbol(symbol: "concat")                                                                       // malstep(7,8,9,A)
let kSymbolCons             = MalSymbol(symbol: "cons")                                                                         // malstep(7,8,9,A)
let kSymbolDef              = MalSymbol(symbol: "def!")                                                                         // malstep(3,4,5,6,7,8,9,A)
let kSymbolDefMacro         = MalSymbol(symbol: "defmacro!")                                                                    // malstep(8,9,A)
let kSymbolDo               = MalSymbol(symbol: "do")                                                                           // malstep(4,5,6,7,8,9,A)
let kSymbolEval             = MalSymbol(symbol: "eval")                                                                         // malstep(6,7,8,9,A)
let kSymbolFn               = MalSymbol(symbol: "fn*")                                                                          // malstep(4,5,6,7,8,9,A)
let kSymbolIf               = MalSymbol(symbol: "if")                                                                           // malstep(4,5,6,7,8,9,A)
let kSymbolLet              = MalSymbol(symbol: "let*")                                                                         // malstep(3,4,5,6,7,8,9,A)
let kSymbolMacroExpand      = MalSymbol(symbol: "macroexpand")                                                                  // malstep(8,9,A)
let kSymbolQuasiQuote       = MalSymbol(symbol: "quasiquote")                                                                   // malstep(7,8,9,A)
let kSymbolQuote            = MalSymbol(symbol: "quote")                                                                        // malstep(7,8,9,A)
let kSymbolSpliceUnquote    = MalSymbol(symbol: "splice-unquote")                                                               // malstep(7,8,9,A)
let kSymbolUnquote          = MalSymbol(symbol: "unquote")                                                                      // malstep(7,8,9,A)
let kSymbolTry              = MalSymbol(symbol: "try*")                                                                         // malstep(9,A)
                                                                                                                                // malstep(3,4,5,6,7,8,9,A)
// Class to help control the incrementing and decrementing of EVAL_level. We                                                    // malstep(5,6,7,8,9,A)
// create one of these on entry to EVAL, incrementing the level. When the                                                       // malstep(5,6,7,8,9,A)
// variable goes out of scope, the object is destroyed, decrementing the level.                                                 // malstep(5,6,7,8,9,A)
//                                                                                                                              // malstep(5,6,7,8,9,A)
class EVAL_Counter {                                                                                                            // malstep(5,6,7,8,9,A)
    init() {                                                                                                                    // malstep(5,6,7,8,9,A)
        ++EVAL_level                                                                                                            // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(5,6,7,8,9,A)
    deinit {                                                                                                                    // malstep(5,6,7,8,9,A)
        --EVAL_level                                                                                                            // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(5,6,7,8,9,A)
}                                                                                                                               // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
//
// >>> NOTE: There are two versions of the following function: one used in step
// >>> 0 and one used in all subsequent versions.
//

// Parse the string into an AST.                                                                                                // malstep(0,1,2,3,4,5,6,7,8,9,A)
//                                                                                                                              // malstep(0,1,2,3,4,5,6,7,8,9,A)
func READ(str: String) -> String {                                                                                              // malstep(0)
    return str                                                                                                                  // malstep(0)
}                                                                                                                               // malstep(0)
func READ(str: String) -> MalVal {                                                                                              // malstep(1,2,3,4,5,6,7,8,9,A)
    return read_str(str)                                                                                                        // malstep(1,2,3,4,5,6,7,8,9,A)
}                                                                                                                               // malstep(1,2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(0,1,2,3,4,5,6,7,8,9,A)
// Return whether or not `val` is a non-empty list.                                                                             // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
func is_pair(val:MalVal) -> Bool {                                                                                              // malstep(7,8,9,A)
    if !is_sequence(val) { return false }                                                                                       // malstep(7,8,9,A)
    let list = val as! MalSequence                                                                                              // malstep(7,8,9,A)
    return !list.isEmpty                                                                                                        // malstep(7,8,9,A)
}                                                                                                                               // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
// Expand macros for as long as the expression looks like a macro invocation.                                                   // malstep(8,9,A)
//                                                                                                                              // malstep(8,9,A)
func macroexpand(var ast:MalVal, env:Environment) -> MalVal {                                                                   // malstep(8,9,A)
    while true {                                                                                                                // malstep(8,9,A)
        if !is_list(ast) { break }                                                                                              // malstep(8,9,A)
        let ast_as_list = ast as! MalList                                                                                       // malstep(8,9,A)
        if ast_as_list.isEmpty { break }                                                                                        // malstep(8,9,A)
        let first = ast_as_list.first()                                                                                         // malstep(8,9,A)
        if !is_symbol(first) { break }                                                                                          // malstep(8,9,A)
        let macro_name = first as! MalSymbol                                                                                    // malstep(8,9,A)
        let obj = env.get(macro_name)                                                                                           // malstep(8,9,A)
        if obj == nil { break }                                                                                                 // malstep(8,9,A)
        if !is_closure(obj!) { break }                                                                                          // malstep(8,9,A)
        let macro = obj! as! MalClosure                                                                                         // malstep(8,9,A)
        if !macro.is_macro { break }                                                                                            // malstep(8,9,A)
        var new_env = Environment(outer: macro.env)                                                                             // malstep(8,9,A)
        let rest = ast_as_list.rest()                                                                                           // malstep(8,9,A)
        let res = new_env.set_bindings(macro.args, with_exprs:rest)                                                             // malstep(8,9,A)
        if is_error(res) { return res }                                                                                         // malstep(8,9,A)
        ast = EVAL(macro.body, new_env)                                                                                         // malstep(8,9,A)
    }                                                                                                                           // malstep(8,9,A)
    return ast                                                                                                                  // malstep(8,9,A)
}                                                                                                                               // malstep(8,9,A)
                                                                                                                                // malstep(8,9,A)
// Evaluate `quasiquote`, possibly recursing in the process.                                                                    // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
// As with quote, unquote, and splice-unquote, quasiquote takes a single                                                        // malstep(7,8,9,A)
// parameter, typically a list. In the general case, this list is processed                                                     // malstep(7,8,9,A)
// recursively as:                                                                                                              // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
//  (quasiquote (first rest...)) -> (cons (quasiquote first) (quasiquote rest))                                                 // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
// In the processing of the parameter passed to it, quasiquote handles three                                                    // malstep(7,8,9,A)
// special cases:                                                                                                               // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
//  *   If the parameter is an atom or an empty list, the following expression                                                  // malstep(7,8,9,A)
//      is formed and returned for evaluation:                                                                                  // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
//          (quasiquote atom-or-empty-list) -> (quote atom-or-empty-list)                                                       // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
//  *   If the first element of the non-empty list is the symbol "unquote"                                                      // malstep(7,8,9,A)
//      followed by a second item, the second item is returned as-is:                                                           // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
//          (quasiquote (unquote fred)) -> fred                                                                                 // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
//  *   If the first element of the non-empty list is another list containing                                                   // malstep(7,8,9,A)
//      the symbol "splice-unquote" followed by a list, that list is catenated                                                  // malstep(7,8,9,A)
//      with the quasiquoted result of the remaining items in the non-empty                                                     // malstep(7,8,9,A)
//      parent list:                                                                                                            // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
//          (quasiquote (splice-unquote list) rest...) -> (items-from-list items-from-quasiquote(rest...))                      // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
// Note the inconsistent handling between "quote" and "splice-quote". The former                                                // malstep(7,8,9,A)
// is handled when this function is handed a list that starts with "quote",                                                     // malstep(7,8,9,A)
// whereas the latter is handled when this function is handled a list whose                                                     // malstep(7,8,9,A)
// first element is a list that starts with "splice-quote". The handling of the                                                 // malstep(7,8,9,A)
// latter is forced by the need to incorporate the results of (splice-quote                                                     // malstep(7,8,9,A)
// list) with the remaining items of the list containing that splice-quote                                                      // malstep(7,8,9,A)
// expression. However, it's not clear to me why the handling of "unquote" is                                                   // malstep(7,8,9,A)
// not handled similarly, for consistency's sake.                                                                               // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
func quasiquote(qq_arg:MalVal) -> MalVal {                                                                                      // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
    // If the argument is an atom or empty list:                                                                                // malstep(7,8,9,A)
    //                                                                                                                          // malstep(7,8,9,A)
    // Return: (quote <argument>)                                                                                               // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
    if !is_pair(qq_arg) {                                                                                                       // malstep(7,8,9,A)
        return MalList(objects: kSymbolQuote, qq_arg)                                                                           // malstep(7,8,9,A)
    }                                                                                                                           // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
    // The argument is a non-empty list -- that is (item rest...)                                                               // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
    // If the first item from the list is a symbol and it's "unquote" -- that                                                   // malstep(7,8,9,A)
    // is, (unquote item ignored...):                                                                                           // malstep(7,8,9,A)
    //                                                                                                                          // malstep(7,8,9,A)
    // Return: item                                                                                                             // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
    let qq_list = qq_arg as! MalSequence                                                                                        // malstep(7,8,9,A)
    if is_symbol(qq_list.first()) {                                                                                             // malstep(7,8,9,A)
        let sym = qq_list.first() as! MalSymbol                                                                                 // malstep(7,8,9,A)
        if sym == kSymbolUnquote {                                                                                              // malstep(7,8,9,A)
            return qq_list.count >= 2 ? qq_list[1] : MalNil()                                                                   // malstep(7,8,9,A)
        }                                                                                                                       // malstep(7,8,9,A)
    }                                                                                                                           // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
    // If the first item from the list is itself a non-empty list starting with                                                 // malstep(7,8,9,A)
    // "splice-unquote"-- that is, ((splice-unquote item ignored...) rest...):                                                  // malstep(7,8,9,A)
    //                                                                                                                          // malstep(7,8,9,A)
    // Return: (concat item quasiquote(rest...))                                                                                // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
    if is_pair(qq_list.first()) {                                                                                               // malstep(7,8,9,A)
        let qq_list_item0 = qq_list.first() as! MalSequence                                                                     // malstep(7,8,9,A)
        if is_symbol(qq_list_item0.first()) {                                                                                   // malstep(7,8,9,A)
            let sym = qq_list_item0.first() as! MalSymbol                                                                       // malstep(7,8,9,A)
            if sym == kSymbolSpliceUnquote {                                                                                    // malstep(7,8,9,A)
                let result = quasiquote(qq_list.rest())                                                                         // malstep(7,8,9,A)
                if is_error(result) { return result }                                                                           // malstep(7,8,9,A)
                return MalList(array: [kSymbolConcat, qq_list_item0[1], result])                                                // malstep(7,8,9,A)
            }                                                                                                                   // malstep(7,8,9,A)
        }                                                                                                                       // malstep(7,8,9,A)
    }                                                                                                                           // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
    // General case: (item rest...):                                                                                            // malstep(7,8,9,A)
    //                                                                                                                          // malstep(7,8,9,A)
    // Return: (cons (quasiquote item) (quasiquote (rest...))                                                                   // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
    let first = quasiquote(qq_list.first())                                                                                     // malstep(7,8,9,A)
    if is_error(first) { return first }                                                                                         // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
    let rest = quasiquote(qq_list.rest())                                                                                       // malstep(7,8,9,A)
    if is_error(rest) { return rest }                                                                                           // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
    return MalList(objects: kSymbolCons, first, rest)                                                                           // malstep(7,8,9,A)
}                                                                                                                               // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
// Perform a simple evaluation of the `ast` object. If it's a symbol,                                                           // malstep(2,3,4,5,6,7,8,9,A)
// dereference it and return its value. If it's a collection, call EVAL on all                                                  // malstep(2,3,4,5,6,7,8,9,A)
// elements (or just the values, in the case of the hashmap). Otherwise, return                                                 // malstep(2,3,4,5,6,7,8,9,A)
// the object unchanged.                                                                                                        // malstep(2,3,4,5,6,7,8,9,A)
//                                                                                                                              // malstep(2,3,4,5,6,7,8,9,A)
func eval_ast(ast: MalVal, env: Environment) -> MalVal {                                                                        // malstep(2,3,4,5,6,7,8,9,A)
    switch ast.type {                                                                                                           // malstep(2,3,4,5,6,7,8,9,A)
        case .TypeSymbol:                                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
            let symbol = ast as! MalSymbol                                                                                      // malstep(2,3,4,5,6,7,8,9,A)
            if let val = env.get(symbol) {                                                                                      // malstep(2,3,4,5,6,7,8,9,A)
                return val                                                                                                      // malstep(2,3,4,5,6,7,8,9,A)
            }                                                                                                                   // malstep(2,3,4,5,6,7,8,9,A)
            return MalError(message: "'\(symbol)' not found")    // Specific text needed to match MAL unit tests                // malstep(2,3,4,5,6,7,8,9,A)
        case .TypeList:                                                                                                         // malstep(2,3,4,5,6,7,8,9,A)
            let list = ast as! MalList                                                                                          // malstep(2,3,4,5,6,7,8,9,A)
            var result = [MalVal]()                                                                                             // malstep(2,3,4,5,6,7,8,9,A)
            result.reserveCapacity(list.count)                                                                                  // malstep(2,3,4,5,6,7,8,9,A)
            for item in list {                                                                                                  // malstep(2,3,4,5,6,7,8,9,A)
                let eval = EVAL(item, env)                                                                                      // malstep(2,3,4,5,6,7,8,9,A)
                if is_error(eval) { return eval }                                                                               // malstep(2,3,4,5,6,7,8,9,A)
                result.append(eval)                                                                                             // malstep(2,3,4,5,6,7,8,9,A)
            }                                                                                                                   // malstep(2,3,4,5,6,7,8,9,A)
            return MalList(array: result)                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
        case .TypeVector:                                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
            let vec = ast as! MalVector                                                                                         // malstep(2,3,4,5,6,7,8,9,A)
            var result = [MalVal]()                                                                                             // malstep(2,3,4,5,6,7,8,9,A)
            result.reserveCapacity(vec.count)                                                                                   // malstep(2,3,4,5,6,7,8,9,A)
            for item in vec {                                                                                                   // malstep(2,3,4,5,6,7,8,9,A)
                let eval = EVAL(item, env)                                                                                      // malstep(2,3,4,5,6,7,8,9,A)
                if is_error(eval) { return eval }                                                                               // malstep(2,3,4,5,6,7,8,9,A)
                result.append(eval)                                                                                             // malstep(2,3,4,5,6,7,8,9,A)
            }                                                                                                                   // malstep(2,3,4,5,6,7,8,9,A)
            return MalVector(array: result)                                                                                     // malstep(2,3,4,5,6,7,8,9,A)
        case .TypeHashMap:                                                                                                      // malstep(2,3,4,5,6,7,8,9,A)
            let hash = ast as! MalHashMap                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
            var result = [MalVal]()                                                                                             // malstep(2,3,4,5,6,7,8,9,A)
            result.reserveCapacity(hash.count * 2)                                                                              // malstep(2,3,4,5,6,7,8,9,A)
            for (k, v) in hash {                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
                let new_v = EVAL(v, env)                                                                                        // malstep(2,3,4,5,6,7,8,9,A)
                if is_error(new_v) { return new_v }                                                                             // malstep(2,3,4,5,6,7,8,9,A)
                result.append(k)                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
                result.append(new_v)                                                                                            // malstep(2,3,4,5,6,7,8,9,A)
            }                                                                                                                   // malstep(2,3,4,5,6,7,8,9,A)
            return MalHashMap(array: result)                                                                                    // malstep(2,3,4,5,6,7,8,9,A)
        default:                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
            return ast                                                                                                          // malstep(2,3,4,5,6,7,8,9,A)
    }                                                                                                                           // malstep(2,3,4,5,6,7,8,9,A)
}                                                                                                                               // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
enum TCOVal {                                                                                                                   // malstep(5,6,7,8,9,A)
    case NoResult                                                                                                               // malstep(5,6,7,8,9,A)
    case Return(MalVal)                                                                                                         // malstep(5,6,7,8,9,A)
    case Continue(MalVal, Environment)                                                                                          // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
    init() { self = .NoResult }                                                                                                 // malstep(5,6,7,8,9,A)
    init(_ result: MalVal) { self = .Return(result) }                                                                           // malstep(5,6,7,8,9,A)
    init(_ ast: MalVal, _ env: Environment) { self = .Continue(ast, env) }                                                      // malstep(5,6,7,8,9,A)
    init(_ e: String) { self = .Return(MalError(message: e)) }                                                                  // malstep(5,6,7,8,9,A)
}                                                                                                                               // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
// EVALuate "def!".                                                                                                             // malstep(3,4,5,6,7)
// EVALuate "def!" and "defmacro!".                                                                                             // malstep(8,9,A)
//                                                                                                                              // malstep(3,4,5,6,7,8,9,A)
func eval_def(list: MalSequence, env: Environment) -> MalVal {                                                                  // malstep(3,4)
func eval_def(list: MalSequence, env: Environment) -> TCOVal {                                                                  // malstep(5,6,7,8,9,A)
    if list.count != 3 {                                                                                                        // malstep(3,4,5,6,7,8,9,A)
        return MalError(message: "expected 2 arguments to def!, got \(list.count - 1)")                                         // malstep(3,4)
        return TCOVal("expected 2 arguments to def!, got \(list.count - 1)")                                                    // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(3,4,5,6,7,8,9,A)
    let arg0 = list[0] as! MalSymbol                                                                                            // malstep(8,9,A)
    let arg1 = list[1]                                                                                                          // malstep(3,4,5,6,7,8,9,A)
    let arg2 = list[2]                                                                                                          // malstep(3,4,5,6,7,8,9,A)
    if !is_symbol(arg1) {                                                                                                       // malstep(3,4,5,6,7,8,9,A)
        return MalError(message: "expected symbol for first argument to def!")                                                  // malstep(3,4)
        return TCOVal("expected symbol for first argument to def!")                                                             // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(3,4,5,6,7,8,9,A)
    let sym = arg1 as! MalSymbol                                                                                                // malstep(3,4,5,6,7,8,9,A)
    let value = EVAL(arg2, env)                                                                                                 // malstep(3,4,5,6,7,8,9,A)
    if is_error(value) { return value }                                                                                         // malstep(3,4)
    if is_error(value) { return TCOVal(value) }                                                                                 // malstep(5,6,7,8,9,A)
    if arg0 == kSymbolDefMacro {                                                                                                // malstep(8,9,A)
        if is_closure(value) {                                                                                                  // malstep(8,9,A)
            let as_closure = value as! MalClosure                                                                               // malstep(8,9,A)
            as_closure.is_macro = true                                                                                          // malstep(8,9,A)
        } else {                                                                                                                // malstep(8,9,A)
            return TCOVal("expected closure, got \(value)")                                                                     // malstep(8,9,A)
        }                                                                                                                       // malstep(8,9,A)
    }                                                                                                                           // malstep(8,9,A)
    return env.set(sym, value)                                                                                                  // malstep(3,4)
    return TCOVal(env.set(sym, value))                                                                                          // malstep(5,6,7,8,9,A)
}                                                                                                                               // malstep(3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(3,4,5,6,7,8,9,A)
// EVALuate "let*".                                                                                                             // malstep(3,4,5,6,7,8,9,A)
//                                                                                                                              // malstep(3,4,5,6,7,8,9,A)
func eval_let(list: MalSequence, env: Environment) -> MalVal {                                                                  // malstep(3,4)
func eval_let(list: MalSequence, env: Environment) -> TCOVal {                                                                  // malstep(5,6,7,8,9,A)
    if list.count != 3 {                                                                                                        // malstep(3,4,5,6,7,8,9,A)
        return MalError(message: "expected 2 arguments to let*, got \(list.count - 1)")                                         // malstep(3,4)
        return TCOVal("expected 2 arguments to let*, got \(list.count - 1)")                                                    // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(3,4,5,6,7,8,9,A)
    let arg1 = list[1]                                                                                                          // malstep(3,4,5,6,7,8,9,A)
    let arg2 = list[2]                                                                                                          // malstep(3,4,5,6,7,8,9,A)
    if !is_sequence(arg1) {                                                                                                     // malstep(3,4,5,6,7,8,9,A)
        return MalError(message: "expected list for first argument to let*")                                                    // malstep(3,4)
        return TCOVal("expected list for first argument to let*")                                                               // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(3,4,5,6,7,8,9,A)
    let bindings = arg1 as! MalSequence                                                                                         // malstep(3,4,5,6,7,8,9,A)
    if bindings.count % 2 == 1 {                                                                                                // malstep(3,4,5,6,7,8,9,A)
        return MalError(message: "expected even number of elements in bindings to let*, got \(bindings.count)")                 // malstep(3,4)
        return TCOVal("expected even number of elements in bindings to let*, got \(bindings.count)")                            // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(3,4,5,6,7,8,9,A)
    var new_env = Environment(outer: env)                                                                                       // malstep(3,4,5,6,7,8,9,A)
    for var index = 0; index < bindings.count; index += 2 {                                                                     // malstep(3,4,5,6,7,8,9,A)
        let binding_name = bindings[index]                                                                                      // malstep(3,4,5,6,7,8,9,A)
        let binding_value = bindings[index + 1]                                                                                 // malstep(3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(3,4,5,6,7,8,9,A)
        if !is_symbol(binding_name) {                                                                                           // malstep(3,4,5,6,7,8,9,A)
            return MalError(message: "expected symbol for first element in binding pair")                                       // malstep(3,4)
            return TCOVal("expected symbol for first element in binding pair")                                                  // malstep(5,6,7,8,9,A)
        }                                                                                                                       // malstep(3,4,5,6,7,8,9,A)
        let binding_symbol = binding_name as! MalSymbol                                                                         // malstep(3,4,5,6,7,8,9,A)
        let evaluated_value = EVAL(binding_value, new_env)                                                                      // malstep(3,4,5,6,7,8,9,A)
        if is_error(evaluated_value) { return evaluated_value }                                                                 // malstep(3,4)
        if is_error(evaluated_value) { return TCOVal(evaluated_value) }                                                         // malstep(5,6,7,8,9,A)
        new_env.set(binding_symbol, evaluated_value)                                                                            // malstep(3,4,5,6,7,8,9,A)
    }                                                                                                                           // malstep(3,4,5,6,7,8,9,A)
    if TCO {                                                                                                                    // malstep(5,6,7,8,9,A)
        return TCOVal(arg2, new_env)                                                                                            // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(5,6,7,8,9,A)
    return EVAL(arg2, new_env)                                                                                                  // malstep(3,4)
    return TCOVal(EVAL(arg2, new_env))                                                                                          // malstep(5,6,7,8,9,A)
}                                                                                                                               // malstep(3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(3,4,5,6,7,8,9,A)
// EVALuate "do".                                                                                                               // malstep(4,5,6,7,8,9,A)
//                                                                                                                              // malstep(4,5,6,7,8,9,A)
func eval_do(list: MalSequence, env: Environment) -> MalVal {                                                                   // malstep(4)
func eval_do(list: MalSequence, env: Environment) -> TCOVal {                                                                   // malstep(5,6,7,8,9,A)
    if TCO {                                                                                                                    // malstep(5,6,7,8,9,A)
        let eval = eval_ast(MalList(slice: list[1..<list.count-1]), env)                                                        // malstep(5,6,7,8,9,A)
        if is_error(eval) { return TCOVal(eval) }                                                                               // malstep(5,6,7,8,9,A)
        return TCOVal(list.last(), env)                                                                                         // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
    let evaluated_ast = eval_ast(list.rest(), env)                                                                              // malstep(4,5,6,7,8,9,A)
    if is_error(evaluated_ast) { return evaluated_ast }                                                                         // malstep(4)
    if is_error(evaluated_ast) { return TCOVal(evaluated_ast) }                                                                 // malstep(5,6,7,8,9,A)
    let evaluated_seq = evaluated_ast as! MalSequence                                                                           // malstep(4,5,6,7,8,9,A)
    return evaluated_seq.last()                                                                                                 // malstep(4)
    return TCOVal(evaluated_seq.last())                                                                                         // malstep(5,6,7,8,9,A)
}                                                                                                                               // malstep(4,5,6,7,8,9,A)
                                                                                                                                // malstep(4,5,6,7,8,9,A)
// EVALuate "if".                                                                                                               // malstep(4,5,6,7,8,9,A)
//                                                                                                                              // malstep(4,5,6,7,8,9,A)
func eval_if(list: MalSequence, env: Environment) -> MalVal {                                                                   // malstep(4)
func eval_if(list: MalSequence, env: Environment) -> TCOVal {                                                                   // malstep(5,6,7,8,9,A)
    if list.count < 3 {                                                                                                         // malstep(4,5,6,7,8,9,A)
        return MalError(message: "expected at least 2 arguments to if, got \(list.count - 1)")                                  // malstep(4)
        return TCOVal("expected at least 2 arguments to if, got \(list.count - 1)")                                             // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(4,5,6,7,8,9,A)
    let cond_result = EVAL(list[1], env)                                                                                        // malstep(4,5,6,7,8,9,A)
    var new_ast = MalVal()                                                                                                      // malstep(4,5,6,7,8,9,A)
    if is_truthy(cond_result) {                                                                                                 // malstep(4,5,6,7,8,9,A)
        new_ast = list[2]                                                                                                       // malstep(4,5,6,7,8,9,A)
    } else if list.count == 4 {                                                                                                 // malstep(4,5,6,7,8,9,A)
        new_ast = list[3]                                                                                                       // malstep(4,5,6,7,8,9,A)
    } else {                                                                                                                    // malstep(4,5,6,7,8,9,A)
        return MalNil()                                                                                                         // malstep(4)
        return TCOVal(MalNil())                                                                                                 // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(4,5,6,7,8,9,A)
    if TCO {                                                                                                                    // malstep(5,6,7,8,9,A)
        return TCOVal(new_ast, env)                                                                                             // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(5,6,7,8,9,A)
    return EVAL(new_ast, env)                                                                                                   // malstep(4)
    return TCOVal(EVAL(new_ast, env))                                                                                           // malstep(5,6,7,8,9,A)
}                                                                                                                               // malstep(4,5,6,7,8,9,A)
                                                                                                                                // malstep(4,5,6,7,8,9,A)
// EVALuate "fn*".                                                                                                              // malstep(4,5,6,7,8,9,A)
//                                                                                                                              // malstep(4,5,6,7,8,9,A)
func eval_fn(list: MalSequence, env: Environment) -> MalVal {                                                                   // malstep(4)
func eval_fn(list: MalSequence, env: Environment) -> TCOVal {                                                                   // malstep(5,6,7,8,9,A)
    if list.count != 3 {                                                                                                        // malstep(4,5,6,7,8,9,A)
        return MalError(message: "expected 2 arguments to fn*, got \(list.count - 1)")                                          // malstep(4)
        return TCOVal("expected 2 arguments to fn*, got \(list.count - 1)")                                                     // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(4,5,6,7,8,9,A)
    if !is_sequence(list[1]) {                                                                                                  // malstep(4,5,6,7,8,9,A)
        return MalError(message: "expected list or vector for first argument to fn*")                                           // malstep(4)
        return TCOVal("expected list or vector for first argument to fn*")                                                      // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(4,5,6,7,8,9,A)
    return MalClosure(eval: EVAL, args:list[1] as! MalSequence, body:list[2], env:env)                                          // malstep(4)
    return TCOVal(MalClosure(eval: EVAL, args:list[1] as! MalSequence, body:list[2], env:env))                                  // malstep(5,6,7,8,9,A)
}                                                                                                                               // malstep(4,5,6,7,8,9,A)
                                                                                                                                // malstep(4,5,6,7,8,9,A)
// EVALuate "quote".                                                                                                            // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
func eval_quote(list: MalSequence, env: Environment) -> TCOVal {                                                                // malstep(7,8,9,A)
    if list.count >= 2 {                                                                                                        // malstep(7,8,9,A)
        return TCOVal(list[1])                                                                                                  // malstep(7,8,9,A)
    }                                                                                                                           // malstep(7,8,9,A)
    return TCOVal(MalNil())                                                                                                     // malstep(7,8,9,A)
}                                                                                                                               // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
// EVALuate "quasiquote".                                                                                                       // malstep(7,8,9,A)
//                                                                                                                              // malstep(7,8,9,A)
func eval_quasiquote(list: MalSequence, env: Environment) -> TCOVal {                                                           // malstep(7,8,9,A)
    if list.count >= 2 {                                                                                                        // malstep(7,8,9,A)
        if TCO {                                                                                                                // malstep(7,8,9,A)
            return TCOVal(quasiquote(list[1]), env)                                                                             // malstep(7,8,9,A)
        }                                                                                                                       // malstep(7,8,9,A)
        return TCOVal(EVAL(quasiquote(list[1]), env))                                                                           // malstep(7,8,9,A)
    }                                                                                                                           // malstep(7,8,9,A)
    return TCOVal("Expected non-nil parameter to 'quasiquote'")                                                                 // malstep(7,8,9,A)
}                                                                                                                               // malstep(7,8,9,A)
                                                                                                                                // malstep(7,8,9,A)
// EVALuate "macroexpand".                                                                                                      // malstep(8,9,A)
//                                                                                                                              // malstep(8,9,A)
func eval_macroexpand(list: MalSequence, env: Environment) -> TCOVal {                                                          // malstep(8,9,A)
    if list.count >= 2 {                                                                                                        // malstep(8,9,A)
        return TCOVal(macroexpand(list[1], env))                                                                                // malstep(8,9,A)
    }                                                                                                                           // malstep(8,9,A)
    return TCOVal("Expected parameter to 'macroexpand'")                                                                        // malstep(8,9,A)
}                                                                                                                               // malstep(8,9,A)
                                                                                                                                // malstep(8,9,A)
// EVALuate "try*" (and "catch*").                                                                                              // malstep(9,A)
//                                                                                                                              // malstep(9,A)
func eval_try(list: MalSequence, env: Environment) -> TCOVal {                                                                  // malstep(9,A)
    // This is a subset of the Clojure try/catch:                                                                               // malstep(9,A)
    //                                                                                                                          // malstep(9,A)
    //      (try* expr (catch exception-name expr))                                                                             // malstep(9,A)
                                                                                                                                // malstep(9,A)
    if list.count < 2 {                                                                                                         // malstep(9,A)
        println("try*: no body parameter")                                                                                      // malstep(9,A)
        return TCOVal(MalNil()) // No body parameter                                                                            // malstep(9,A)
    }                                                                                                                           // malstep(9,A)
    let res = EVAL(list[1], env)                                                                                                // malstep(9,A)
    if !is_error(res) { return TCOVal(res) }                                                                                    // malstep(9,A)
    if list.count < 3 {                                                                                                         // malstep(9,A)
        println("try*: no catch parameter")                                                                                     // malstep(9,A)
        return TCOVal(MalNil()) // No catch parameter                                                                           // malstep(9,A)
    }                                                                                                                           // malstep(9,A)
    if !is_sequence(list[2]) {                                                                                                  // malstep(9,A)
        println("try*: second parameter to 'try' is not a sequence")                                                            // malstep(9,A)
        return TCOVal(MalNil()) // Second parameter to 'try' is not a sequence                                                  // malstep(9,A)
    }                                                                                                                           // malstep(9,A)
    let catch_list = list[2] as! MalSequence                                                                                    // malstep(9,A)
    if catch_list.count < 3 {                                                                                                   // malstep(9,A)
        println("try*: not enough catch parameters")                                                                            // malstep(9,A)
        return TCOVal(MalNil()) // Not enough catch parameters                                                                  // malstep(9,A)
    }                                                                                                                           // malstep(9,A)
    if !is_symbol(catch_list[0]) {                                                                                              // malstep(9,A)
        println("try*: first parameter in catch list is not a symbol")                                                          // malstep(9,A)
        return TCOVal(MalNil()) // First parameter in catch list is not a symbol                                                // malstep(9,A)
    }                                                                                                                           // malstep(9,A)
    let catch_symbol = catch_list[0] as! MalSymbol                                                                              // malstep(9,A)
    if catch_symbol != kSymbolCatch {                                                                                           // malstep(9,A)
        println("try*: first parameter in catch list is not 'catch'")                                                           // malstep(9,A)
        return TCOVal(MalNil()) // First parameter in catch list is not 'catch'                                                 // malstep(9,A)
    }                                                                                                                           // malstep(9,A)
    if !is_symbol(catch_list[1]) {                                                                                              // malstep(9,A)
        println("try*: first parameter to 'catch' is not a symbol")                                                             // malstep(9,A)
        return TCOVal(MalNil()) // First parameter to 'catch' is not a symbol                                                   // malstep(9,A)
    }                                                                                                                           // malstep(9,A)
    let catch_name = catch_list[1] as! MalSymbol                                                                                // malstep(9,A)
    let catch_expr = catch_list[2]                                                                                              // malstep(9,A)
    let catch_env = Environment(outer: env)                                                                                     // malstep(9,A)
    let error = res as! MalError                                                                                                // malstep(9,A)
    catch_env.set_bindings(MalList(objects: catch_name), with_exprs: MalList(objects: error.value))                             // malstep(9,A)
    return TCOVal(EVAL(catch_expr, catch_env))                                                                                  // malstep(9,A)
}                                                                                                                               // malstep(9,A)
                                                                                                                                // malstep(9,A)
//
// >>> NOTE: There are several versions of the EVAL function. One is used in
// >>> step 0, one is used in step 1, and a final one is used in step 2 and all
// >>> subsequent versions. This final version is extended throughout the
// >>> project through the addition of functionality.
//

// Walk the AST and completely evaluate it, handling macro expansions, special                                                  // malstep(0,1,2,3,4,5,6,7,8,9,A)
// forms and function calls.                                                                                                    // malstep(0,1,2,3,4,5,6,7,8,9,A)
//                                                                                                                              // malstep(0,1,2,3,4,5,6,7,8,9,A)
func EVAL(ast: String) -> String {                                                                                              // malstep(0)
    return ast                                                                                                                  // malstep(0)
}                                                                                                                               // malstep(0)
func EVAL(ast: MalVal) -> MalVal {                                                                                              // malstep(1)
    if is_error(ast) { return ast }                                                                                             // malstep(1)
    return ast                                                                                                                  // malstep(1)
}                                                                                                                               // malstep(1)
func EVAL(var ast: MalVal, var env: Environment) -> MalVal {                                                                    // malstep(2,3,4,5,6,7,8,9,A)
    let x = EVAL_Counter()                                                                                                      // malstep(5,6,7,8,9,A)
    if EVAL_level > EVAL_leval_max {                                                                                            // malstep(5,6,7,8,9,A)
        return MalError(message: "Recursing too many levels (> \(EVAL_leval_max))")                                             // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
    if DEBUG_EVAL {                                                                                                             // malstep(5,6,7,8,9,A)
        indent = prefix(INDENT_TEMPLATE, EVAL_level)                                                                            // malstep(5,6,7,8,9,A)
    }                                                                                                                           // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
    while true {                                                                                                                // malstep(5,6,7,8,9,A)
        if is_error(ast) { return ast }                                                                                         // malstep(2,3,4,5,6,7,8,9,A)
        if DEBUG_EVAL { println("\(indent)>   \(ast)") }                                                                        // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        if !is_list(ast) {                                                                                                      // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
            // Not a list -- just evaluate and return.                                                                          // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
            let answer = eval_ast(ast, env)                                                                                     // malstep(2,3,4,5,6,7,8,9,A)
            if DEBUG_EVAL { println("\(indent)>>> \(answer)") }                                                                 // malstep(5,6,7,8,9,A)
            return answer                                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
        }                                                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        // Special handling if it's a list.                                                                                     // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        var list = ast as! MalList                                                                                              // malstep(2,3,4,5,6,7,8,9,A)
        ast = macroexpand(ast, env)                                                                                             // malstep(8,9,A)
        if !is_list(ast) { return ast }                                                                                         // malstep(8,9,A)
        list = ast as! MalList                                                                                                  // malstep(8,9,A)
                                                                                                                                // malstep(8,9,A)
        if DEBUG_EVAL { println("\(indent)>.  \(list)") }                                                                       // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        if list.isEmpty {                                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
            return list                                                                                                         // malstep(2,3,4,5,6,7,8,9,A)
        }                                                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        // Check for special forms, where we want to check the operation                                                        // malstep(3,4,5,6,7,8,9,A)
        // before evaluating all of the parameters.                                                                             // malstep(3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(3,4,5,6,7,8,9,A)
        let arg0 = list.first()                                                                                                 // malstep(3,4,5,6,7,8,9,A)
        if is_symbol(arg0) {                                                                                                    // malstep(3,4,5,6,7,8,9,A)
            var res: TCOVal                                                                                                     // malstep(5,6,7,8,9,A)
            let fn_symbol = arg0 as! MalSymbol                                                                                  // malstep(3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(3,4,5,6,7,8,9,A)
            switch fn_symbol {                                                                                                  // malstep(3,4,5,6,7,8,9,A)
                case kSymbolDef:            return eval_def(list, env)                                                          // malstep(3,4)
                case kSymbolDef:            res = eval_def(list, env)                                                           // malstep(5,6,7,8,9,A)
                case kSymbolDefMacro:       res = eval_def(list, env)                                                           // malstep(8,9,A)
                case kSymbolLet:            return eval_let(list, env)                                                          // malstep(3,4)
                case kSymbolLet:            res = eval_let(list, env)                                                           // malstep(5,6,7,8,9,A)
                case kSymbolDo:             return eval_do(list, env)                                                           // malstep(4)
                case kSymbolDo:             res = eval_do(list, env)                                                            // malstep(5,6,7,8,9,A)
                case kSymbolIf:             return eval_if(list, env)                                                           // malstep(4)
                case kSymbolIf:             res = eval_if(list, env)                                                            // malstep(5,6,7,8,9,A)
                case kSymbolFn:             return eval_fn(list, env)                                                           // malstep(4)
                case kSymbolFn:             res = eval_fn(list, env)                                                            // malstep(5,6,7,8,9,A)
                case kSymbolQuote:          res = eval_quote(list, env)                                                         // malstep(7,8,9,A)
                case kSymbolQuasiQuote:     res = eval_quasiquote(list, env)                                                    // malstep(7,8,9,A)
                case kSymbolMacroExpand:    res = eval_macroexpand(list, env)                                                   // malstep(8,9,A)
                case kSymbolTry:            res = eval_try(list, env)                                                           // malstep(9,A)
                default:                    break                                                                               // malstep(3,4)
                default:                    res = TCOVal()                                                                      // malstep(5,6,7,8,9,A)
            }                                                                                                                   // malstep(3,4,5,6,7,8,9,A)
            switch res {                                                                                                        // malstep(5,6,7,8,9,A)
                case let .Return(result):               return result                                                           // malstep(5,6,7,8,9,A)
                case let .Continue(new_ast, new_env):   ast = new_ast; env = new_env; continue                                  // malstep(5,6,7,8,9,A)
                case .NoResult:                         break                                                                   // malstep(5,6,7,8,9,A)
            }                                                                                                                   // malstep(5,6,7,8,9,A)
        }                                                                                                                       // malstep(3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(3,4,5,6,7,8,9,A)
        // Standard list to be applied. Evaluate all the elements first.                                                        // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        let eval = eval_ast(ast, env)                                                                                           // malstep(2,3,4,5,6,7,8,9,A)
        if is_error(eval) { return eval }                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        // The result had better be a list and better be non-empty.                                                             // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        let eval_list = eval as! MalList                                                                                        // malstep(2,3,4,5,6,7,8,9,A)
        if eval_list.isEmpty {                                                                                                  // malstep(2,3,4,5,6,7,8,9,A)
            return eval_list                                                                                                    // malstep(2,3,4,5,6,7,8,9,A)
        }                                                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        if DEBUG_EVAL { println("\(indent)>>  \(eval)") }                                                                       // malstep(5,6,7,8,9,A)
                                                                                                                                // malstep(5,6,7,8,9,A)
        // Get the first element of the list and execute it.                                                                    // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        let first = eval_list.first()                                                                                           // malstep(2,3,4,5,6,7,8,9,A)
        let rest = eval_list.rest()                                                                                             // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        if is_builtin(first) {                                                                                                  // malstep(2,3,4,5,6,7,8,9,A)
            let fn = first as! MalBuiltin                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
            let answer = fn.apply(rest)                                                                                         // malstep(2,3,4,5,6,7,8,9,A)
            if DEBUG_EVAL { println("\(indent)>>> \(answer)") }                                                                 // malstep(5,6,7,8,9,A)
            return answer                                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
        } else if is_closure(first) {                                                                                           // malstep(4,5,6,7,8,9,A)
            let fn = first as! MalClosure                                                                                       // malstep(4,5,6,7,8,9,A)
            var new_env = Environment(outer: fn.env)                                                                            // malstep(4,5,6,7,8,9,A)
            let result = new_env.set_bindings(fn.args, with_exprs:rest)                                                         // malstep(4,5,6,7,8,9,A)
            if is_error(result) { return result }                                                                               // malstep(4,5,6,7,8,9,A)
            if TCO {                                                                                                            // malstep(5,6,7,8,9,A)
                env = new_env                                                                                                   // malstep(5,6,7,8,9,A)
                ast = fn.body                                                                                                   // malstep(5,6,7,8,9,A)
                continue                                                                                                        // malstep(5,6,7,8,9,A)
            }                                                                                                                   // malstep(5,6,7,8,9,A)
            let answer = EVAL(fn.body, new_env)                                                                                 // malstep(4,5,6,7,8,9,A)
            if DEBUG_EVAL { println("\(indent)>>> \(answer)") }                                                                 // malstep(5,6,7,8,9,A)
            return answer                                                                                                       // malstep(4,5,6,7,8,9,A)
        }                                                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        // The first element wasn't a function to be executed. Return an                                                        // malstep(2,3,4,5,6,7,8,9,A)
        // error saying so.                                                                                                     // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        return MalError(message: "first list item does not evaluate to a function: \(first)")                                   // malstep(2,3,4,5,6,7,8,9,A)
    }                                                                                                                           // malstep(5,6,7,8,9,A)
}                                                                                                                               // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(0,1,2,3,4,5,6,7,8,9,A)
// Convert the value into a human-readable string for printing.                                                                 // malstep(0,1,2,3,4,5,6,7,8,9,A)
//                                                                                                                              // malstep(0,1,2,3,4,5,6,7,8,9,A)
func PRINT(exp: String) -> String {                                                                                             // malstep(0)
    return exp                                                                                                                  // malstep(0)
}                                                                                                                               // malstep(0)
func PRINT(exp: MalVal) -> String? {                                                                                            // malstep(1,2,3,4,5,6,7,8,9,A)
    if is_error(exp) { return nil }                                                                                             // malstep(1,2,3,4,5,6,7,8,9,A)
    return pr_str(exp, true)                                                                                                    // malstep(1,2,3,4,5,6,7,8,9,A)
}                                                                                                                               // malstep(1,2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(0,1,2,3,4,5,6,7,8,9,A)
//
// >>> NOTE: The following function has several versions. Also note that the
// >>> call to EVAL comes in two flavors.
//

// Perform the READ and EVAL steps. Useful for when you don't care about the                                                    // malstep(0,1,2,3,4,5,6,7,8,9,A)
// printable result.                                                                                                            // malstep(0,1,2,3,4,5,6,7,8,9,A)
//                                                                                                                              // malstep(0,1,2,3,4,5,6,7,8,9,A)
func RE(text: String) -> String {                                                                                               // malstep(0)
    let ast = READ(text)                                                                                                        // malstep(0)
    let exp = EVAL(ast)                                                                                                         // malstep(0)
    return exp                                                                                                                  // malstep(0)
}                                                                                                                               // malstep(0)
func RE(text: String) -> MalVal? {                                                                                              // malstep(1)
func RE(text: String, env: Environment) -> MalVal? {                                                                            // malstep(2,3,4,5,6,7,8,9,A)
    if text.isEmpty { return nil }                                                                                              // malstep(1,2,3,4,5,6,7,8,9,A)
    let ast = READ(text)                                                                                                        // malstep(1,2,3,4,5,6,7,8,9,A)
    if is_error(ast) {                                                                                                          // malstep(1,2,3,4,5,6,7,8,9,A)
        println("Error parsing input: \(ast)")                                                                                  // malstep(1,2,3,4,5,6,7,8,9,A)
        return nil                                                                                                              // malstep(1,2,3,4,5,6,7,8,9,A)
    }                                                                                                                           // malstep(1,2,3,4,5,6,7,8,9,A)
    let exp = EVAL(ast)                                                                                                         // malstep(1)
    let exp = EVAL(ast, env)                                                                                                    // malstep(2,3,4,5,6,7,8,9,A)
    if is_error(exp) {                                                                                                          // malstep(1,2,3,4,5,6,7,8,9,A)
        println("Error evaluating input: \(exp)")                                                                               // malstep(1,2,3,4,5,6,7,8,9,A)
        return nil                                                                                                              // malstep(1,2,3,4,5,6,7,8,9,A)
    }                                                                                                                           // malstep(1,2,3,4,5,6,7,8,9,A)
    return exp                                                                                                                  // malstep(1,2,3,4,5,6,7,8,9,A)
}                                                                                                                               // malstep(1,2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(0,1,2,3,4,5,6,7,8,9,A)
//
// >>> NOTE: The following function has several versions.
//

// Perform the full READ/EVAL/PRINT, returning a printable string.                                                              // malstep(0,1,2,3,4,5,6,7,8,9,A)
//                                                                                                                              // malstep(0,1,2,3,4,5,6,7,8,9,A)
func REP(text: String) -> String {                                                                                              // malstep(0)
    let exp = RE(text)                                                                                                          // malstep(0)
    return PRINT(exp)                                                                                                           // malstep(0)
}                                                                                                                               // malstep(0)
func REP(text: String) -> String? {                                                                                             // malstep(1)
    let exp = RE(text)                                                                                                          // malstep(1)
    if exp == nil { return nil }                                                                                                // malstep(1)
    return PRINT(exp!)                                                                                                          // malstep(1)
}                                                                                                                               // malstep(1)
func REP(text: String, env: Environment) -> String? {                                                                           // malstep(2,3,4,5,6,7,8,9,A)
    let exp = RE(text, env)                                                                                                     // malstep(2,3,4,5,6,7,8,9,A)
    if exp == nil { return nil }                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
    return PRINT(exp!)                                                                                                          // malstep(2,3,4,5,6,7,8,9,A)
}                                                                                                                               // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(0,1,2,3,4,5,6,7,8,9,A)
//
// >>> NOTE: The following function has several versions.
//

// Perform the full REPL.                                                                                                       // malstep(0,1,2,3,4,5,6,7,8,9,A)
//                                                                                                                              // malstep(0,1,2,3,4,5,6,7,8,9,A)
func REPL() {                                                                                                                   // malstep(0)
    while true {                                                                                                                // malstep(0)
        if let text = _readline("user> ") {                                                                                     // malstep(0)
            println("\(REP(text))")                                                                                             // malstep(0)
        } else {                                                                                                                // malstep(0)
            println()                                                                                                           // malstep(0)
            break                                                                                                               // malstep(0)
        }                                                                                                                       // malstep(0)
    }                                                                                                                           // malstep(0)
}                                                                                                                               // malstep(0)
func REPL() {                                                                                                                   // malstep(1)
    while true {                                                                                                                // malstep(1)
        if let text = _readline("user> ") {                                                                                     // malstep(1)
            if let output = REP(text) {                                                                                         // malstep(1)
                println("\(output)")                                                                                            // malstep(1)
            }                                                                                                                   // malstep(1)
        } else {                                                                                                                // malstep(1)
            println()                                                                                                           // malstep(1)
            break                                                                                                               // malstep(1)
        }                                                                                                                       // malstep(1)
    }                                                                                                                           // malstep(1)
}                                                                                                                               // malstep(1)
func REPL(env: Environment) {                                                                                                   // malstep(2,3,4,5,6,7,8,9,A)
    while true {                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
        if let text = _readline("user> ") {                                                                                     // malstep(2,3,4,5,6,7,8,9,A)
            if let output = REP(text, env) {                                                                                    // malstep(2,3,4,5,6,7,8,9,A)
                println("\(output)")                                                                                            // malstep(2,3,4,5,6,7,8,9,A)
            }                                                                                                                   // malstep(2,3,4,5,6,7,8,9,A)
        } else {                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
            println()                                                                                                           // malstep(2,3,4,5,6,7,8,9,A)
            break                                                                                                               // malstep(2,3,4,5,6,7,8,9,A)
        }                                                                                                                       // malstep(2,3,4,5,6,7,8,9,A)
    }                                                                                                                           // malstep(2,3,4,5,6,7,8,9,A)
}                                                                                                                               // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(0,1,2,3,4,5,6,7,8,9,A)
// Process any command line arguments. Any trailing arguments are incorporated                                                  // malstep(6,7,8,9,A)
// into the environment. Any argument immediately after the process name is                                                     // malstep(6,7,8,9,A)
// taken as a script to execute. If one exists, it is executed in lieu of                                                       // malstep(6,7,8,9,A)
// running the REPL.                                                                                                            // malstep(6,7,8,9,A)
//                                                                                                                              // malstep(6,7,8,9,A)
func process_command_line(args:[String], env:Environment) -> Bool {                                                             // malstep(6,7,8,9,A)
    var argv = MalList()                                                                                                        // malstep(6,7,8,9,A)
    if args.count > 2 {                                                                                                         // malstep(6,7,8,9,A)
        let args1 = args[2..<args.count]                                                                                        // malstep(6,7,8,9,A)
        let args2 = args1.map { MalString(unescaped: $0) as MalVal }                                                            // malstep(6,7,8,9,A)
        let args3 = [MalVal](args2)                                                                                             // malstep(6,7,8,9,A)
        argv = MalList(array: args3)                                                                                            // malstep(6,7,8,9,A)
    }                                                                                                                           // malstep(6,7,8,9,A)
    env.set(kSymbolArgv, argv)                                                                                                  // malstep(6,7,8,9,A)
                                                                                                                                // malstep(6,7,8,9,A)
    if args.count > 1 {                                                                                                         // malstep(6,7,8,9,A)
        RE("(load-file \"\(args[1])\")", env)                                                                                   // malstep(6,7,8,9,A)
        return false                                                                                                            // malstep(6,7,8,9,A)
    }                                                                                                                           // malstep(6,7,8,9,A)
                                                                                                                                // malstep(6,7,8,9,A)
    return true                                                                                                                 // malstep(6,7,8,9,A)
}                                                                                                                               // malstep(6,7,8,9,A)
                                                                                                                                // malstep(6,7,8,9,A)
func main() {                                                                                                                   // malstep(0,1,2,3,4,5,6,7,8,9,A)
    var env = Environment(outer: nil)                                                                                           // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
    load_history_file()                                                                                                         // malstep(0,1,2,3,4,5,6,7,8,9,A)
    load_builtins(env)                                                                                                          // malstep(2,3,4,5,6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
    RE("(def! *host-language* \"swift\")", env);                                                                                // malstep(A)
    RE("(def! not (fn* (a) (if a false true)))", env)                                                                           // malstep(4,5,6,7,8,9,A)
    RE("(def! load-file (fn* (f) (eval (read-string (str \"(do \" (slurp f) \")\")))))", env)                                   // malstep(6,7,8,9,A)
    RE("(defmacro! cond (fn* (& xs) (if (> (count xs) 0) (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) " +               // malstep(8,9,A)
       "(throw \"odd number of forms to cond\")) (cons 'cond (rest (rest xs)))))))", env)                                       // malstep(8,9,A)
    RE("(defmacro! or (fn* (& xs) (if (empty? xs) nil (if (= 1 (count xs)) (first xs) " +                                       // malstep(8,9,A)
       "`(let* (or_FIXME ~(first xs)) (if or_FIXME or_FIXME (or ~@(rest xs))))))))", env)                                       // malstep(8,9,A)
                                                                                                                                // malstep(6,7,8,9,A)
    env.set(kSymbolEval, MalBuiltin(function: {                                                                                 // malstep(6,7,8,9,A)
         unwrap($0) {                                                                                                           // malstep(6,7,8,9,A)
            (ast:MalVal) -> MalVal in                                                                                           // malstep(6,7,8,9,A)
            EVAL(ast, env)                                                                                                      // malstep(6,7,8,9,A)
         }                                                                                                                      // malstep(6,7,8,9,A)
    }))                                                                                                                         // malstep(6,7,8,9,A)
                                                                                                                                // malstep(6,7,8,9,A)
//
// >>> NOTE: The call to REPL() is managed in three different ways. First, we
// >>> just call it with no parameters. Second, we call it with an "env"
// >>> parameter.  Finally, we call it only if there is no program on the
// >>> command line to execute.
//
    REPL()                                                                                                                      // malstep(0,1)
    REPL(env)                                                                                                                   // malstep(2,3,4,5)
    if process_command_line(Process.arguments, env) {                                                                           // malstep(6,7,8,9,A)
        RE("(println (str \"Mal [\" *host-language*\"]\"))", env);                                                              // malstep(A)
        REPL(env)                                                                                                               // malstep(6,7,8,9,A)
    }                                                                                                                           // malstep(6,7,8,9,A)
                                                                                                                                // malstep(2,3,4,5,6,7,8,9,A)
    save_history_file()                                                                                                         // malstep(0,1,2,3,4,5,6,7,8,9,A)
}                                                                                                                               // malstep(0,1,2,3,4,5,6,7,8,9,A)
